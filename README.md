# Recursion_and_closure

Сегодня узнаем про Recursion и Closure
# Recursion
<div align="center">
  <img src="https://miro.medium.com/v2/resize:fit:750/1*qmeSaOhOpgH0tkwg7W5QeQ.jpeg" width="600px" height="300px">
</div>

> Рекурсия в JavaScript — это процесс, при котором функция вызывает сама себя. Это мощный инструмент, который позволяет решать задачи, которые можно разбить на несколько подзадач аналогичной структуры. Важно, чтобы рекурсивная функция имела условие завершения, чтобы избежать бесконечных вызовов.

Пример простейшей рекурсии: вычисление факториала числа.
```js
function factorial(n) {
  // Условие завершения
  if (n === 0 || n === 1) {
    return 1;
  }
  // Рекурсивный вызов
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
```
> В этом примере функция factorial вызывает саму себя, уменьшая значение n на 1 на каждом шаге, пока не достигнет базового случая (когда n равен 0 или 1).

### Принципы рекурсии:
> Базовый случай: Это условие, при котором рекурсия прекращается. Без этого условия рекурсия может привести к бесконечному циклу.
> Рекурсивный случай: Это вызов функции с аргументами, которые приближают решение задачи к базовому случаю.
> Рекурсия часто используется для обхода деревьев (например, в структурах данных или при обработке XML/JSON).

### Пример: Вычисление суммы чисел от 1 до N:
```js
function sum(n) {
  // Базовый случай: если n равно 1, возвращаем 1
  if (n === 1) {
    return 1;
  }

  // Рекурсивный случай: складываем текущую цифру с результатом рекурсивного вызова для меньшего числа
  return n + sum(n - 1);
}

console.log(sum(5)); // 15 (5 + 4 + 3 + 2 + 1)
```

### Объяснение:
* Функция sum принимает число n и возвращает сумму чисел от 1 до n.
* Базовый случай: если n равно 1, возвращаем 1 — это завершение рекурсии.
* Рекурсивный случай: функция вызывает себя с меньшим значением n, пока не достигнет базового случая.

## Плюсы и минусы рекурсии:
### Преимущества:
> Удобство и краткость кода, особенно при решении задач, которые естественно поддаются рекурсивному решению (например, задачи на разбиение, обход графов и деревьев).

### Недостатки:
> Рекурсия может привести к переполнению стека, если глубина рекурсии слишком велика (в случае слишком глубоких вызовов). В таких случаях лучше использовать итерации или оптимизированные алгоритмы, такие как > > хвостовая рекурсия (в некоторых языках это оптимизируется на уровне компилятора).

### Хвостовая рекурсия
> Если рекурсивный вызов является последним действием в функции (хвостовой вызов), то компилятор может оптимизировать этот вызов, избегая излишнего использования памяти для хранения стека вызовов. Однако в JavaScript хвостовая рекурсия не всегда оптимизируется, поэтому важно учитывать это при глубокой рекурсии.

# Closure

<div align="center">
  <img src="https://almablog-media.s3.ap-south-1.amazonaws.com/Frame_854_7db723b032.png" width="600px" height="300px">
</div>

> Closure (Замыкание) — это функция, которая "запоминает" своё лексическое окружение, даже когда она выполняется за пределами своей исходной области видимости. Другими словами, замыкание позволяет функции сохранять доступ к переменным, определённым в её внешней функции, даже после того, как эта внешняя функция завершила выполнение.

### Пример замыкания:
```js
function outer() {
  let outerVar = 'I am from outer function';
  
  function inner() {
    console.log(outerVar); // inner() имеет доступ к outerVar
  }
  
  return inner; // Возвращаем inner как замыкание
}

const closureFunction = outer(); // outer() возвращает inner()
closureFunction(); // 'I am from outer function'
```

### Объяснение:
В этом примере функция inner является замыканием, потому что она использует переменную outerVar, которая была определена в функции outer.
Когда мы вызываем outer(), она возвращает функцию inner, которая продолжает иметь доступ к переменной outerVar, даже если выполнение outer уже завершено.
При вызове closureFunction() (что является вызовом inner), замыкание всё ещё имеет доступ к переменной outerVar.

## Как работает замыкание?
> Замыкание сохраняет ссылку на все переменные, которые были в его области видимости на момент создания, даже если эти переменные больше не доступны из внешнего кода. Это достигается за счёт того, что функции в JavaScript могут захватывать и использовать переменные их лексического окружения.

### Пример с инкрементом:
```js
function createCounter() {
  let count = 0;
  
  return function() {
    count++;
    console.log(count);
  };
}

const counter = createCounter();
counter(); // 1
counter(); // 2
counter(); // 3
```

### Объяснение:
Функция createCounter возвращает функцию, которая инкрементирует и выводит значение переменной count. Эта переменная сохраняется в замыкании, обеспечивая доступ к ней при каждом вызове возвращённой функции, даже если createCounter уже завершила выполнение.

## Преимущества замыканий:
* Инкапсуляция: Замыкания позволяют скрывать внутренние переменные от внешнего кода, обеспечивая доступ к ним только через функции, которые их используют.
* Функции с состоянием: Замыкания позволяют создавать функции, которые сохраняют своё состояние между вызовами, как в примере с счётчиком.

### Использование замыканий:
* Создание приватных переменных: Замыкания используются для создания приватных данных, которые не могут быть напрямую изменены из внешнего кода.
* Функции обратного вызова и обработчики событий: Замыкания часто используются в обработчиках событий, где нужно сохранить доступ к переменным, определённым в родительской функции.

### Важные моменты:
> Замыкания могут приводить к накоплению памяти, если они используются неправильно, так как они сохраняют ссылки на переменные, даже если они больше не нужны.
Замыкания могут быть сложными для отладки, особенно если они скрывают детали внутренней работы.

---

<div align="center">
  <img src="https://a.d-cd.net/fGkj61MC91njUbKjZUahzEm1-IA-960.jpg" width="600px" height="300px">
</div>

---
